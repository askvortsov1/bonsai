
# Directory organization

This directory contains code for quickcheck-generating random Bonsai
computations. The goal is to check new Bonsai compiler optimizations with
quickcheck. A few quickcheck tests of optimizations are included.

`quickcheck/src/bonsai_quickcheck_internal.ml` contains all of the source code
for generating computations. `src/to_code.ml` contains code for producing valid
OCaml source code from the generated computation.

`quickcheck/test/bonsai_quickcheck_test.ml` includes a few quickcheck tests of
Bonsai optimizations as well as sanity-check testing for the generator itself.
`test/bad_opts.ml` includes a bad optimization that should cause the quickcheck
tests to fail. This helps check that the quickcheck generator is actually
catching mistakes that it should.

`quickcheck/bin` creates the executable main.exe with commands for printing out
the sexp or the valid OCaml source code for randomly generated computations. It
also includes a test to the printer in that it copies the generated source code
for one hardcoded computation to a `.ml` file which then gets built with the rest
of the directory.

# Approach

Since the Bonsai computation is a GADT, we can't just derive quickcheck and get
a quickcheck generator. Furthermore, even if  you could, you likely would not
get a useful generator as it would not generate computations that are realistic
and stress the compiler in interesting ways. We solve these problems by
manually implementing the quickcheck generator for a "fake" `bonsai_quickcheck`
computation type that is more constrained and easier to work with, and then we
convert that output to a real Bonsai computation.

## Generating Computations

To generate computations, we first define our own `bonsai_quickcheck` value and
computation types. They do not include all of the constructors of the real
versions, but they could later be expanded to handle more. These types are
parametrized by the output type. For example, a Value.Map that takes in an int
and returns a unit is a `unit Value.t` in `bonsai_quickcheck`.

We also define a Witness type that is used to keep track of the types of
`bonsai_quickcheck` values and computations by matching on the witness.

We also define a "fake function" type for `bonsai_quickcheck`. Though
`quickcheck` does have a function generator, this does not work for these
purposes for several reasons.

First, these generated functions are not very realistic of real functions. They
work by observing the input and then returning randomly generated output of the
right type. They are a function of the input because the input perturbs the
random state during observation. However, this is not what realistic functions
look like.

Second, these functions do not take into account any of the other variables
in scope. It also doesn't leave the variable in scope for later. This leaves
gaps for some incorrect optimizations that throw away or incorrectly alter the
inputs to pass quickcheck testing. For example, using the regular quickcheck
function generator allows the `bad_sub` optimization to pass.

Third, using a "real" function of any kind, including those generated by the
regular quickcheck function generator means that the function is not printable
and its inner workings are hidden. This means that the functions cannot be
printed or expressed in valid OCaml code. Printing out the generated
computations is very important for debugging and assessing the distribution, so
being able to print functions was necessary.

Our `Function.t` type solves these problems. The fake function type can handle
arbitrary input and output types with the Const constructor, which is just a
constant function of the correct type. However, it also includes some
special-case constructors for specific matching input and output types.

We also wanted to be able to generate actions that could be executed on the
computation as those one might get from the Bonsai.state constructor. In order
to achieve this, we make a special witness type for top-level computation
generation. This witness includes a regular random witness as the first element
of a tuple and a tuple tree of state-type witnesses as the second element. This
guarantees that the generator will make a Computation with at least this amount
of actions that can then be extracted and run on the Computation.

## Generating Realistic/Interesting Computations

Defining what it means for a computation to be realistic and interesting is
non-trivial. We used a couple heuristics for deciding whether the computation
was realistic. First, the quickcheck tester should catch bad optimizations.
Secondly, it should use the values it generates. For example, it should not
call a function and then never use its output. Thirdly, the values in its
output should use previously computed values whenever possible instead of
returning constants.

Judging whether the quickcheck tester catches bad optimizations comes from
simply coming up with bad optimizations and then testing those. We implement
and test one example of this, but more should be done.

We allow the quickcheck generator to use the values it generates by passing
values in scope down to inner computations with a `context` parameter that gets
passed to the value and computation generators. Then, when a value is needed,
the context is first searched for something of the correct type before
something new is generated.

We try to ensure there will be useful things in the context by making the
witnesses of inner computations and values dependent on the ultimate goal
witness. The `goal_list` parameter contains witnesses that are parts of the
ultimate goal list (ie, the witnesses on either side of a tuple). Inner
computations are more likely to pull witnesses from the goal list than generate
random ones. Then, at the end of the computation, the generator is likely to
have all the pieces it needs to construct the final result.

Two constants are defined at the top of `bonsai_quickcheck_internal.ml`:
`weight_scalar` and `size_scalar`. `weight_scalar` is used to make certain
cases more or less likely by this factor, sometimes dependent on factors like
the witness passed to the generator. `size_scalar` is used to make the size of
the max recursion depth smaller during witness generation so that the witness
is guaranteed to be smaller than the computation. The exact values of these
constants is purely based on manual testing and judgement calls as to what
seemed to work well. More empirical testing could be  useful to determine what
these constants should be, or if there should be more granularity in constants
instead of using the same one in all cases.

Next steps
---------------------------------
There is a lot of work left to do to flesh out this generator more.

First, more bad optimizations and testing could ensure that the quickcheck
generator is doing its job and catch cases where it is not.

Second. more scientific and thorough investigation of the distribution could
be done to more precisely tune constants and make the generated computations
more realistic.

Thirdly, more thinking needs to be done about what is exposed in the library's
.mli file. Right now, more is exposed than users should ultimately need to
think about and have access to. Also, there are a couple functions that could
make this library actually useful to people writing Bonsai computations, such
as being able to quickcheck test by randomly generate surrounding computation.

Fourth, more data types would make the generator more expressive. Right now,
the generator can only handle base data types of units and ints. It can then
combine these types into eithers, Tuple2's, maps, or Bonsai effect functions
`'a -> unit Bonsai.Effect.t`. More constructors for `bonsai_internal`'s `Value.t`
and `Computation.t` types would also make the generator more expressive.
